# C++/C 

#### [ ] 1.0 

#### [ ] 

**[ ]** (^2001 7 24) 


#### / 

#### V 0.9 2001-7-1 

#### 2001-7-18 

#### V 1.0 2001-7-18 

#### 2001-7-24 

#### V 0.9 


#### .......................................................................................................................................6 

#### 1 ....................................................................................................................8 

#### 1.1 ........................................................................................................8 

#### 1.2 ...............................................................................................................8 

#### 1.3 ...........................................................................................................8 

#### 1.4 ...............................................................................................................8 

#### 1.5 .......................................................................................................................8 

#### 2 ................................................................................................................8 

#### 2.1 ...............................................................................................................................8 

#### 2.2 ...........................................................................................................................8 

#### 2.3 ...........................................................................................................8 

#### 2.4 ...............................................................................................................................8 

#### 2.5 .......................................................................................................................8 

#### 2.6 ...............................................................................................................8 

#### 2.7 ...............................................................................................................................8 

#### 2.8 .......................................................................................................................8 

#### 3 ....................................................................................................................8 

#### 3.1 .......................................................................................................................8 

#### 3.2 W INDOWS .........................................................................8 

#### 3.3 U NIX ..................................................................................8 

#### 4 ....................................................................................................8 

#### 4.1 ...........................................................................................................8 

#### 4.2 ...................................................................................................................8 

#### 4.3 IF ...........................................................................................................................8 

#### 4.4 ...........................................................................................................8 

#### 4.5 FOR ............................................................................................8 

#### 4.6 SWITCH ..................................................................................................................8 

#### 4.7 GOTO ......................................................................................................................8 

#### 5 ............................................................................................................................8 

#### 5.1 ...........................................................................................................8 

#### 5.2 CONST # DEFINE ...........................................................................................8 

#### 5.3 ...............................................................................................................8 

#### 5.4 ...................................................................................................................8 

#### 6 ....................................................................................................................8 


#### 6.1 ...................................................................................................................8 

#### 6.2 ...............................................................................................................8 

#### 6.3 ....................................................................................................8 

#### 6.4 .......................................................................................................................8 

#### 6.5 .......................................................................................................................8 

#### 6.6 ........................................................................................................8 

#### 7 ....................................................................................................................8 

#### 7.1 ................................................................................................................8 

#### 7.2 .............................................................................................8 

#### 7.3 ........................................................................................................8 

#### 7.4 .....................................................................................8 

#### 7.5 FREE DELETE .................................................................................8 

#### 7.6 ........................................................................................8 

#### 7.7 ...........................................................................................................8 

#### 7.8 MALLOC / FREE NEW / DELETE .......................................................8 

#### 7.9 ........................................................................................................8 

#### 7.10 MALLOC / FREE .........................................................................................8 

#### 7.11 NEW / DELETE ...........................................................................................8 

#### 7.12 .............................................................................................................8 

#### 8 C++ .................................................................................................8 

#### 8.1 ...........................................................................................................8 

#### 8.2 ....................................................................................8 

#### 8.3 ...............................................................................................................8 

#### 8.4 ...................................................................................................................8 

#### 8.5 .......................................................................................................................8 

#### 8.6 ...............................................................................................................8 

#### 9 .....................................................................8 

#### 9.1 ........................................................................................8 

#### 9.2 ....................................................................................................8 

#### 9.3 ........................................................................................................8 

#### 9.4 S TRING ..................................................................8 

#### 9.5 ............................................................................8 

#### 9.6 S TRING ..........................................................8 

#### 9.7 .................................................................8 

#### 9.8 ............................................................................8 

#### 9.9 ...............................................................................................................8 

#### 10 ......................................................................................................8 


#### 10.1 .............................................................................................................................8 

#### 10.2 .............................................................................................................................8 

#### 11 ..........................................................................................................8 

#### 11.1 CONST ..................................................................................8 

#### 11.2 ..........................................................................................................8 

#### 11.3 ..........................................................................................................8 

#### .................................................................................................................................8 

#### A C++/C ................................................................................................8 

#### B C++/C ............................................................................................................8 

#### C C++/C .............................................................................8 


#### C++/C 

#### N-1 

**Internet (1)** 

**(2) (3) (4) (5) (6) (7) (8) (9) 30 (10) 9:00 5:00 9:00** 

**……** 

#### C++/C 

#### CAD 3D 


#### 1995 2000 

#### 10 C++ 3D 

#### 3D 

 strcpy 

#### 1 

#### 2 

#### 3 

#### IT 

#### IT 


#### 1 

#### 2 

 10 if …… 14 C++/C 

#### IT 

#### 1 

#### 2 

#### 1 

#### 2 

#### 3 


#### B C++/C 

#### 1 

#### 2 

#### 3 85 C++/C 

#### 4 

#### C++/C 

 Bug 

#### CMMI 

#### CMMI 


#### C++/C 

#### 1 

#### 2 

#### 3 

#### 2002 7 CMMI 3 

#### 1000 

#### 2001 7 


## 1 

 C++/C declaration implementation definition 

 C++/C .h C .c C++ .cpp .cc .cxx 

### 1.1 

#### 1-1 

#### 1 

#### 2 

#### 3 / 

#### 4 

#### /* 

 * Copyright (c) 2001, * All rights reserved. * * filename.h * * * * 1.1 * * 2001 7 20 * * 1.0 * * 2001 5 10 */ 

 1-1 


### 1.2 

#### 1 1-1 

#### 2 

#### 3 

 graphics.h 1-2 

z **1-2-1 ifndef/define/endif** 

z **1-2-2** #include < **filename.h>** 

z **1-2-3** #include **“filename.h”** 

 **1-2-1 C++** 

 **1-2-2 extern int value** 

#### // 1-1 

 #ifndef GRAPHICS_H // graphics.h #define GRAPHICS_H 

 #include <math.h> // 

 #include “myheader.h” // 

 void Function1( ); // 

 class Box // { 

 }; #endif 1-2 C++/C 


### 1.3 

#### 1 1-1 

#### 2 

#### 3 

 graphics.cpp 1-3 

 // 1-1 

 #include “graphics.h” // 

#### // 

 void Function1( ) { 

 } 

 // void Box::Draw( ) { 

 } 

 1-3 C++/C 

### 1.4 

 Basic Fortran C++/C 

 1 

#### 2 


### 1.5 

 include source 


## 2 

### 2.1 

z **2-1-1 2-1 a** z **2-1-2 2-1 b** 

 // void Function1( ) { 

 } // void Function2( ) { 

 } // void Function3( ) { 

 } 

#### // 

 while (condition) { statement1; // if (condition) { statement2; } else { statement3; } // statement4; } 2-1(a) 2-1(b) 


### 2.2 

z **2-2-1** 

z **2-2-2 if for while do {}** 

 2-2 a 2-2 b 

 int width; // int height; // int depth; // 

 int width, height, depth; // 

 x = a + b; y = c + d; z = e + f; 

 X a + b; y = c + d; z = e + f; 

 if (width < height) { dosomething(); } 

 if (width < height) dosomething(); 

 for (initialization; condition; update) { dosomething(); } // other(); 

 for (initialization; condition; update) dosomething(); other(); 

 2-2(a) 2-2(b) 

 **2-2-1** 

 int width = 10; // width int height = 10; // height int depth = 10; // depth 


### 2.3 

z **2-3-1 const virtual inline case if for while** 

z **2-3-2** z **2-3-3 ;** z **2-3-4 Function(x, y, z) ;** for (initialization; condition; update) z **2-3-5 = += >= <= + * % && || << , ^** 

z **2-3-6! ~ ++ -&** 

z **2-3-7**. ->  **2-3-1 for if** for (i=0; i<10; i++) **if ((a<=b) && (c<=d))** 

 void Func1(int x, int y, int z); // void Func1 (int x,int y,int z); // if (year >= 2000) // if(year>=2000) // if ((a>=b) && (c<=d)) // if(a>=b&&c<=d) // for (i=0; i<10; i++) // for(i=0;i<10;i++) // for (i = 0; I < 10; i ++) // x = a < b? a : b; // x=a<b?a:b; // int *x = &y; // int * x = & y; // array[5] = 0; // array [ 5 ] = 0; a.Function(); // a. Function(); b->Function(); // b -> Function(); 

 2-3 


### 2.4 

z **2-4-1 { }** 

z **2-4-2 { } {** 

 2-4 a 2-4 b 

 void Function(int x) { // program code } 

 void Function(int x){ // program code } 

 if (condition) { // program code } else { // program code } 

 if (condition){ // program code } else { // program code } 

 for (initialization; condition; update) { // program code } 

 for (initialization; condition; update){ // program code } 

 While (condition) { // program code } 

 while (condition){ // program code } 

 { 

 { 

 } 

 } 2-4(a) 2-4(b) 


### 2.5 

z **2-5-1 70 80** 

z **2-5-2** 

 if ((very_longer_variable1 >= very_longer_variable12) && (very_longer_variable3 <= very_longer_variable14) && (very_longer_variable5 <= very_longer_variable16)) { dosomething(); } virtual CMatrix CMultiplyMatrix (CMatrix leftMatrix, CMatrix rightMatrix); 

 for (very_longer_initialization; very_longer_condition; very_longer_update) { dosomething(); } 2-5 

### 2.6 

#### * 

 * int* x; x int int* x, y; y x y 

z **2-6-1 *** 

 char *name; int *x, y; // y 


### 2.7 

#### C /*…*/ C++ /*…*/ 

#### //… 

#### 1 

#### 2 

#### 3 

#### 2-6 

z **2-7-1** 

z **2-7-2** 

i++; // i 1 z **2-7-3** 

z **2-7-4** 

z **2-7-5** z **2-7-6** 

z **2-7-8** 

 2-6 

#### /* 

#### * 

#### * 

#### * 

#### * 

#### */ 

 void Function(float x, float y, float z) { … } 

 if (…) { … while (…) { … } // end of while … } // end of if 


### 2.8 

 public protected private 

 1 private public 8-3 a 

 2 public private 8.3 b 

 C++ Biarne Stroustrup 

 class A { private: int i, j; float x, y; … public: void Func1(void); void Func2(void); … } 

 class A { public: void Func1(void); void Func2(void); … private: int i, j; float x, y; … } 8.3(a) 8.3(b) 


## 3 

 Microsoft 

ch p ppch 

 int i, j, k; float x, y, z; 

 int iI, iJ, ik; // i int float fX, fY, fZ; // f float 

### 3.1 

#### 3.2 

z **3-1-1** 

**CurrentValue NowValue** 

z **3-1-2** min-length && max-information **ANSI C 6** C++/C 

 ! maxval maxValueUntilOverflow i,j,k,m,n,x,y,z 

z **3-1-3 Windows AddChild Unix add_child** 


z **3-1-4** 

 int x, X; // x X void foo(int x); // foo FOO void FOO(float x); 

z **3-1-5** 

z **3-1-6** 

 float value; float oldValue; float newValue; 

z **3-1-7** 

 DrawBox(); // box->Draw(); // 

z **3-1-8** 

 int minValue; int maxValue; 

 int SetValue(…); int GetValue(…); 

 **3-1-1** Value1,Value2 

### 3.2 Windows 

 Windows 


z **3-2-1** 

 class Node; // class LeafNode; // void Draw(void); // void SetValue(int value); // 

z **3-2-2** 

 BOOL flag; int drawMode; 

z **3-2-3** 

 const int MAX = 100; const int MAX_LENGTH = 100; 

z **3-2-4 s_ static** 

 void Init(…) { static int s_initValue; // … } 

z **3-2-5 g_ global** 

 int g_howManyPeople; // int g_howMuchMoney; // 

z **3-2-6 m_ member** 

 void Object::SetValue(int width, int height) { m_width = width; m_height = height; } 


z **3-2-7 OpenGL gl GL** 

### 3.3 Unix 


## 4 

 if for while goto switch 

#### C++/C 

### 4.1 

#### C++/C 4-1 

#### + * 

#### ( ) [ ] ->. 

 ! ~ ++ -sizeof + * & * / % + << >> < <= > >= == != & ^ | && || ?: = += -= *= /= %= &= ^= |= <<= >>= 4-1 

z **4-1-1** 

 4-1 

 word = (high << 8) | low 


 if ((a | b) && (a & c)) 

### 4.2 

 a = b = c = 0 1 2 

z **4-2-1** 

 i = a >= b && c < d && c + f <= g + h ; // 

z **4-2-2** 

 d = (a = b + c) + r ; a d a = b + c; d = a + r; 

z **4-2-3** 

 if (a < b < c) // a < b < c 

 if ((a<b) && (b<c)) 

 if ( (a<b)<c ) 

### 4.3 if 

 if C++/C if 

4.3.1 z **4-3-1 TRUE FALSE 1 0 FALSE TRUE TRUE Visual C++ TRUE 1 Visual Basic TRUE -1** flag **if** if (flag) // flag 


 if (!flag) // flag 

 if (flag == TRUE) if (flag == 1 ) if (flag == FALSE) if (flag == 0) 

4.3.2 z **4-3-2** == = 0 value **if** if (value == 0) if (value != 0) 

 if (value) // value if (!value) 

4.3.3 z **4-3-3** == = float double == = >= <= x if (x == 0.0) // 

 if ((x>=-EPSINON) && (x<=EPSINON)) EPSINON 

4.3.4 z **4-3-4** == = NULL NULL NULL 0 p **if** if (p == NULL) // p NULL p if (p != NULL) 

 if (p == 0) // p if (p != 0) 

 if (p) // p if (!p) 

4.3.5 if 


 if (NULL == p) if (p == NULL) if (p = NULL) p NULL if (p = NULL) if (NULL = p) NULL 

 if/else/return if (condition) return x; return y; 

 if (condition) { return x; } else { return y; } 

 return (condition? x : y); 

### 4.4 

 C++/C for while do 

z **4-4-1** CPU 4-4(b) 4-4(a) 

 for (row=0; row<100; row++) { for ( col=0; col<5; col++ ) { sum = sum + a[row][col]; } } 

 for (col=0; col<5; col++ ) { for (row=0; row<100; row++) { sum = sum + a[row][col]; } } 4-4(a) 4-4(b) 

z **4-4-2** 


 4-4(c) 4-4(d) N-1 

 N 4-4(d) N 4-4(c) 

 for (i=0; i<N; i++) { if (condition) DoSomething(); else DoOtherthing(); } 

 if (condition) { for (i=0; i<N; i++) DoSomething(); } else { for (i=0; i<N; i++) DoOtherthing(); } 4-4(c) 4-4(d) 

### 4.5 for 

z **4-5-1 for for** 

z **4-5-1** for 4-5(a) x 0 =< x < N N N 4-5(b) x 0 =< x <= N-1 N-1 N 4-5(a) 

 for (int x=0; x<N; x++) { 

 } 

 for (int x=0; x<=N-1; x++) { 

 } 4-5(a) 4-5(b) 

### 4.6 switch 

 if switch 


switch if if switch switch switch (variable) { case value1 : break; case value2 : break; 

 default : break; } 

z **4-6-1** case break 

z **4-6-2** default default default : break; default 

### 4.7 goto 

 goto goto goto 

 goto state; String s1, s2; // goto int sum = 0; // goto 

 state: 

 goto C++/C goto goto goto break ; { { { goto error; 


#### } 

#### } 

#### } 

error: 

 goto 


## 5 

 C #define C++ #define const const 

### 5.1 

#### 1 

#### 2 

#### 3 

z **5-1-1** 

 #define MAX 100 /* C */ const int MAX = 100; // C++ const const float PI = 3.14159; // C++ const 

### 5.2 const #define 

 C++ const #define 

 1 const 

 2 const 

z **5-2-1** C++ const const 

### 5.3 

z **5-3-1** 


z **5-3-2** 

 const float RADIUS = 100; const float DIAMETER = RADIUS * 2; 

### 5.4 

 #define const const const const 

 const SIZE class A { const int SIZE = 100; // const int array[SIZE]; // SIZE }; 

 const class A { A(int size); // const int SIZE ; }; A::A(int size) : SIZE(size) // { 

 } A a(100); // a SIZE 100 A b(200); // b SIZE 200 

 const 

 class A { enum { SIZE1 = 100, SIZE2 = 200}; // 


int array1[SIZE1]; int array2[SIZE2]; }; 

 PI=3.14159 


## 6 

#### C++/C 

#### C 

 pass by value pass by pointer C++ pass by reference 6.6 

### 6.1 

z **6-1-1** void 

 void SetValue(int width, int height); // void SetValue(int, int); // float GetValue(void); // float GetValue(); // 

z **6-1-2 StringCopy str1 str2** void StringCopy(char *str1, char *str2); **str1 str2 strSource strDestination strSource strDestination** 

 void StringCopy(char *strSource, char *strDestination); 

 char str[20]; StringCopy(str, Hello World ); // 

z **6-1-3 const** 


 void StringCopy(char *strDestination const char *strSource); 

z **6-1-4 const &** 

####  6-1-1 5 

####  6-1-2 

 C printf int printf(const chat *format[, argument] ); 

### 6.2 

z **6-2-1 C void C++ C++ C C++/ C void** 

z **6-2-2 C getchar** 

 char c; c = getchar(); if (c == EOF) 

**getchar c char getchar char int** int getchar(void); **c char [-128 127] EOF char if getchar** 

z **6-2-3 return C getchar int** 


 getchar getchar EOF EOF 1 getchar int 

 return 

 getchar BOOL GetChar(char *c); gechar GetChar putchar(getchar()); getchar 

####  6-2-1 

 strcpy char *strcpy(char *strDest const char *strSrc); strcpy strSrc strDest strDest 

 char str[20]; int length = strlen( strcpy(str, Hello World ) ); 

 **6-2-2** 

 class String { // String & operate=(const String &other); // friend friend String operate+( const String &s1, const String &s2); private: char *m_data; } 

 String operate = String & String::operate=(const String &other) { if (this == &other) return *this; delete m_data; 


 m_data = new char[strlen(other.data)+1]; strcpy(m_data, other.data); return *this; // *this } 

 String return *this 

 String a,b,c; 

 a = b; // *this a = b = c; // *this 

 String operate + String operate+(const String &s1, const String &s2) { String temp; delete temp.data; // temp.data 0 temp.data = new char[strlen(s1.data) + strlen(s2.data) +1]; strcpy(temp.data, s1.data); strcat(temp.data, s2.data); return temp; } 

 String temp temp 

 c = a + b; a + b c 

### 6.3 

z **6-3-1 assert 6.5** 


z **6-3-2 return return return return** 

 1 return 

 char * Func(void) { char str[] = “ hello world ” ; // str … return str; // } 2 3 return return String(s1 + s2); 

 temp String temp(s1 + s2); return temp; temp temp temp 

 return int(x + y); // 

 int temp = x + y; return temp; int,float,double 

### 6.4 

####  6-4-1 

####  6-4-2 50 

####  6-4-3 


#### C/C++ 

**static static**  **6-4-4** 

 **6-4-5** 

### 6.5 

 Debug Release Debug Release 

 assert Debug 6-5 assert assert 

 void *memcpy(void *pvTo, const void *pvFrom, size_t size) { assert((pvTo != NULL) && (pvFrom != NULL)); // byte *pbTo = (byte *) pvTo; // pvTo byte *pbFrom = (byte *) pvFrom; // pvFrom while(size -> 0 ) *pbTo ++ = *pbFrom ++ ; return pvTo; } 6-5 

**assert Debug Release assert assert assert assert assert assert** 

 [Maguire, p8-p30] 


z **6-5-1** 

z **6-5-2** z **6-5-1** 

z **6-5-2** 

### 6.6 

 C++ n m reference m referent int m; int &n = m; n m n m n m m n m 

 1 2 NULL NULL 3 k i k = j k j k 6 k i i 6 int i = 5; int j = 6; int &k = i; k = j; // k i 6; 

 C++ 

 Func1 x n x n, n 0 void Func1(int x) { x = x + 10; } 


 int n = 0; Func1(n); cout << n = << n << endl; // n = 0 

 Func2 x n n n 10 void Func2(int *x) { (* x) = (* x) + 10; } 

 int n = 0; Func2(&n); cout << n = << n << endl; // n = 10 

Func3 x n x n x n n 10 void Func3(int &x) { x = x + 10; } 

 int n = 0; Func3(n); cout << n = << n << endl; // n = 10 


## 7 

 Bill Gates 640K ought to be enough for everybody Bill Gates 1981 

### 7.1 

#### 1 

 static 2 

 3 malloc new free delete 

### 7.2 

####  

 NULL p assert(p!=NULL) malloc new if(p==NULL) if(p!=NULL) 

 


####  

 1 1 for 

####  

 malloc free new/delete 

 

 1 

 2 return 

 3 free delete NULL 

z **7-2-1** malloc new NULL NULL z **7-2-2** 

z **7-2-3 1 1** 

z **7-2-4** z **7-2-5 free delete NULL** 

### 7.3 

#### C++/C 


#### 7.3.1 

 7-3-1 a 6 hello\0 a a[0]= ‘X’ p world world\0 p[0]= ‘X’ 

 char a[] = “ hello ” ; a[0] = ‘ X ’ ; cout << a << endl; char *p = “ world ” ; // p p[0] = ‘ X ’ ; // cout << p << endl; 7-3-1 

**7.3.2** 7-3-2 a b b = a strcpy b a if(b==a) strcmp 

 p = a a p a p a malloc p strlen(a)+1 strcpy if(p==a) strcmp 

 // … char a[] = "hello"; char b[10]; strcpy(b, a); // b = a; if(strcmp(b, a) == 0) // if (b == a) … // … int len = strlen(a); char *p = (char *)malloc(sizeof(char)*(len+1)); strcpy(p,a); // p = a; if(strcmp(p, a) == 0) // if (p == a) … 7-3-2 


#### 7.3.3 

sizeof 7-3-3 a sizeof(a) 12 **’** 0 **’** p a sizeof(p) 4 sizeof(p) sizeof(char*) p C++/C 

7-3-3 b a sizeof(a) sizeof(char *) 

 char a[] = "hello world"; char *p = a; cout<< sizeof(a) << endl; // 12 cout<< sizeof(p) << endl; // 4 7-3-3 a 

 void Func(char a[100]) { cout<< sizeof(a) << endl; // 4 100 } 7-3-3 b 

### 7.4 

#### 7-4-1 

Test GetMemory(str, 200) str str NULL 

 void GetMemory(char *p, int num) { p = (char *)malloc(sizeof(char) * num); } void Test(void) { char *str = NULL; GetMemory(str, 100); // str NULL strcpy(str, "hello"); // } 7-4-1 


GetMemory p _p _p = p _p p _p _p p GetMemory GetMemory free **7-4-2** 

 void GetMemory2(char **p, int num) { *p = (char *)malloc(sizeof(char) * num); } void Test2(void) { char *str = NULL; GetMemory2(&str, 100); // &str str strcpy(str, "hello"); cout<< str << endl; free(str); } 7-4-2 

#### 7-4-3 

 char *GetMemory3(int num) { char *p = (char *)malloc(sizeof(char) * num); return p; } void Test3(void) { char *str = NULL; str = GetMemory3(100); strcpy(str, "hello"); cout<< str << endl; free(str); } 7-4-3 


 return return 7-4-4 

 char *GetString(void) { char p[] = "hello world"; return p; // } void Test4(void) { char *str = NULL; str = GetString(); // str cout<< str << endl; } 7-4-4 return 

 Test4 str = GetString str NULL str “ hello world ” 7-4-4 7-4-5 

 char *GetString2(void) { char *p = "hello world"; return p; } void Test5(void) { char *str = NULL; str = GetString2(); cout<< str << endl; } 7-4-5 return 

Test5 GetString2 GetString2 hello world GetString2 


### 7.5 free delete 

 free delete delete 

 7-5 p free NULL p p NULL p p p if (p != NULL) if p NULL 

 char *p = (char *) malloc(100); strcpy(p, “ hello ” ); free(p); // p p … if(p != NULL) // { strcpy(p, “ world ” ); // } 7-5 p 

### 7.6 

#### 7-6 

 p 

 void Func(void) { char *p = (char *) malloc(100); // } 7-6 

#### 1 

#### 2 NULL 


#### NULL 

### 7.7 

#### NULL NULL 

 if if 

 1 NULL 

 NULL char *p = NULL; char *str = (char *) malloc(100); 

 2 p free delete NULL p 7.5 

 3 class A { public: void Func(void){ cout << “ Func of class A ” << endl; } }; void Test(void) { A *p; { A a; p = &a; // a } p->Func(); // p } 

 Test p->Func() a p a p 


### 7.8 malloc/free new/delete 

 malloc free C++/C new/delete C++ 

 maloc/free 

**malloc/free malloc/free C++ new delete new/delete malloc/free new/delete 7-8** 

 class Obj { public : Obj(void){ cout << “ Initialization ” << endl; } ~Obj(void){ cout << “ Destroy ” << endl; } void Initialize(void){ cout << “ Initialization ” << endl; } void Destroy(void){ cout << “ Destroy ” << endl; } }; void UseMallocFree(void) { Obj *a = (obj *)malloc(sizeof(obj)); // a->Initialize(); // // … a->Destroy(); // free(a); // } void UseNewDelete(void) { Obj *a = new Obj; // // … delete a; // } 7-8 malloc/free new/delete 

 Obj Initialize Destroy UseMallocFree malloc/free Initialize Destroy UseNewDelete 


**malloc/free new/delete malloc/free new/delete** new/delete malloc/free C++ malloc/free C++ C C malloc/free 

 free new delete malloc new/delete malloc/free 

### 7.9 

 malloc new NULL 

 1 NULL return void Func(void) { A *a = new A; if(a == NULL) { return; } … } 

 2 NULL exit(1) void Func(void) { A *a = new A; if(a == NULL) { cout << “ Memory Exhausted ” << endl; exit(1); } … } 

 3 new malloc Visual C++ _set_new_hander 


 new malloc new C++ 

 1 2 1 2 exit(1) 

 exit(1) 

#### 32 

**malloc new Windows 98 Visual C++ 7-9 32** 

**Window 98 32 Unix Windows** 

 void main(void) { float *p = NULL; while(TRUE) { p = new float[1000000]; cout << “ eat memory ” << endl; if(p==NULL) exit(1); } } 7-9 

### 7.10 malloc/free 

 malloc void * malloc(size_t size); malloc length 


int *p = (int *) malloc(sizeof(int) * length); sizeof  malloc void * malloc void *  **malloc int, float int 16 2 32 4 float 16 4 32 4** cout << sizeof(char) << endl; cout << sizeof(int) << endl; cout << sizeof(unsigned int) << endl; cout << sizeof(long) << endl; cout << sizeof(unsigned long) << endl; cout << sizeof(float) << endl; cout << sizeof(double) << endl; cout << sizeof(void *) << endl; 

 malloc () sizeof p = malloc(sizeof(p)) 

 **free** void free( void * memblock ); free malloc p free(p) p NULL free p p NULL free p 

### 7.11 new/delete 

 new malloc int *p1 = (int *)malloc(sizeof(int) * length); int *p2 = new int[length]; new sizeof new new class Obj { public : Obj(void); // 


 Obj(int x); // … } void Test(void) { Obj *a = new Obj; Obj *b = new Obj(1); // 1 … delete a; delete b; } new Obj *objects = new Obj[100]; // 100 

 Obj *objects = new Obj[100](1);// 100 1 delete [] delete []objects; // delete objects; // delete objects[0] 99 

### 7.12 

#### C++/C 

#### C 1 

#### C 

#### 1 

#### 2 


## 8 C++ 

**C C++ overloaded inline const virtual const virtual C++** 

### 8.1 

#### 8.1.1 

#### C++ 

#### C++ 

 8-1-1 EatBeef,EatFish,EatChicken Eat 

 void EatBeef( ); // void Eat(Beef ); void EatFish( ); // void Eat(Fish ); void EatChicken( ); // void Eat(Chicken ); 

 8-1-1 Eat 

 C++ C++ 9 

#### 8.1.2 


 void Function(void); int Function (void); int int x = Function (); Function C++/C Function 

8-1-1 Eat _eat_beef _eat_fish _eat_chicken 

#### C++ C 

#### C 

 void foo(int x, int y); C _foo C++ _foo_int_int C++ C C++ C extern C 

 extern C { void foo(int x, int y); // } 

extern C { #include myheader.h // C } **C++ foo C _foo _foo_int_int C++ C extern C include** 

 void Print( ); // class A { void Print( ); // 


#### } 

Print Print Print :: ::Print( ); // Print 

8.1.3 8-1-3 output int output float output(0.5) 0.5 int float 

 # include <iostream.h> void output( int x); // void output( float x); // 

 void output( int x) { cout << " output int " << x << endl ; } 

 void output( float x) { cout << " output float " << x << endl ; } 

 void main(void) { int x = 1; float y = 1.0; output(x); // output int 1 output(y); // output float 1 output(1); // output int 1 // output(0.5); // error! ambiguous call, output(int(0.5)); // output int 0 output(float(0.5)); // output float 0.5 } 8-1-3 


### 8.2 

 override C++ 

#### 8.2.1 

#### 1 

#### 2 

#### 3 

 4 virtual 

 1 2 3 4 virtual 8-2-1 Base::f(int) Base::f(float) Base::g(void) Derived::g(void) 

 #include <iostream.h> class Base { public: void f(int x){ cout << "Base::f(int) " << x << endl; } void f(float x){ cout << "Base::f(float) " << x << endl; } virtual void g(void){ cout << "Base::g(void)" << endl;} }; 

 class Derived : public Base { public: virtual void g(void){ cout << "Derived::g(void)" << endl;} }; 

 void main(void) { Derived d; Base *pb = &d; pb->f(42); // Base::f(int) 42 


 pb->f(3.14f); // Base::f(float) 3.14 pb->g(); // Derived::g(void) } 8-2-1 

8.2.2 C++ 

 1 virtual 

 2 virtual 

 8-2-2 a 1 Derived::f(float) Base::f(float) 2 Derived::g(int) Base::g(float) 3 Derived::h(float) Base::h(float) 

 #include <iostream.h> class Base { public: virtual void f(float x){ cout << "Base::f(float) " << x << endl; } void g(float x){ cout << "Base::g(float) " << x << endl; } void h(float x){ cout << "Base::h(float) " << x << endl; } }; class Derived : public Base { public: virtual void f(float x){ cout << "Derived::f(float) " << x << endl; } void g(int x){ cout << "Derived::g(int) " << x << endl; } void h(float x){ cout << "Derived::h(float) " << x << endl; } }; 8-2-2 a 

 C++ 

 8-2-2 b bp dp 


 void main(void) { Derived d; Base *pb = &d; Derived *pd = &d; // Good : behavior depends solely on type of the object pb->f(3.14f); // Derived::f(float) 3.14 pd->f(3.14f); // Derived::f(float) 3.14 

 // Bad : behavior depends on type of the pointer pb->g(3.14f); // Base::g(float) 3.14 pd->g(3.14f); // Derived::g(int) 3 (surprise!) 

// Bad : behavior depends on type of the pointer pb->h(3.14f); // Base::h(float) 3.14 (surprise!) pd->h(3.14f); // Derived::h(float) 3.14 } 8-2-2 b 8.2.3 8-2-3 pd->f(10) Base::f(int) Base::f(int) Derived::f(char *) 10 

 class Base { public: void f(int x); }; class Derived : public Base { public: void f(char *str); }; void Test(void) { Derived *pd = new Derived; pd->f(10); // error } 8-2-3 


#### 8-2-3 

 pd->f(10) Derived::f(char *) 

 Derived f pd->f(10) f 

8-2-3 pd->f(10) Base::f(int) Derived class Derived : public Base { public: void f(char *str); void f(int x) { Base::f(x); } }; 

### 8.3 

#### C++ 

z 8-3-1 

 void Foo(int x=0, int y=0); // 

 void Foo(int x=0, int y=0) // { 

 } 

z 8-3-2 

 void Foo(int x, int y=0, int z=0); 


 void Foo(int x=0, int y, int z=0); 

#### 8-3-2 

 output 

 #include <iostream.h> void output( int x); void output( int x, float y=0.0); 

 void output( int x) { cout << " output int " << x << endl ; } 

 void output( int x, float y) { cout << " output int " << x << " and float " << y << endl ; } 

 void main(void) { int x=1; float y=0.5; // output(x); // error! ambiguous call output(x,y); // output int 1 and float 0.5 } 

 8-3-2 

### 8.4 

#### 8.4.1 

 C++ operator 

 Complex Add(const Complex &a, const Complex &b); 


 Complex operator +(const Complex &a, const Complex &b); 

 Complex a, b, c; 

 c = Add(a, b); // c = a + b; // + 

[Murray , p44-p47] 8-4-1 

#### = () [] -> 

#### += -= /= *= &= |= ~= %= >>= <<= 

 8-4-1 

 C++ C 

 1 2 

#### 8.4.2 

#### C++ 

 1 C++ int,float 2.. 3 C++ #,@,$ 

 4 

### 8.5 

#### 8.5.1 


#### C++ 

#### C 

#### CALL 

 return 

 #define MAX(a, b) (a) > (b)? (a) : (b) 

 result = MAX(i, j) + 2 ; 

 result = (i) > (j)? (i) : (j) + 2 ; + : result = ( (i) > (j)? (i) : (j) ) + 2 ; 

 #define MAX(a, b) ( (a) > (b)? (a) : (b) ) 

 result = MAX(i++, j); 

 result = (i++) > (j)? (i++) : (j); C++ 

 C++ 

 this 

 C++ C++ assert assert Debug Debug Release assert assert Debug Release assert 6.5 

8.5.2 inline inline Foo inline void Foo(int x, int y); // inline 


 void Foo(int x, int y) { 

 } Foo void Foo(int x, int y); inline void Foo(int x, int y) // inline { 

 } inline 

 inline inline C++/C 

 class A { public: void Foo(int x, int y) { } // } 

#### // 

 class A { public: void Foo(int x, int y) } // inline void A::Foo(int x, int y) { 

 } 

8.5.3 


#### 1 

#### 2 

 inline 

### 8.6 

#### C++ 

#### C++ 


## 9 

#### A 

#### C++ A 

 A(void); // A(const A &a); // ~A(void); // A & operate =(const A &a); // 

#### 1 

 C++ Stroustrup 2 

#### C++ 

 String String 

 class String { public: String(const char *str = NULL); // String(const String &other); // ~ String(void); // String & operate =(const String &other); // private: char *m_data; // }; 

### 9.1 

#### C C++ C++ 


 Stroustrup C++ 

**Stroustrup** ~ 

 void 

 [Eekel, p55-p56] 

### 9.2 

#### {} 

####  

class A { **…** A(int x); // A }; class B : public A { **…** B(int x, int y);// B }; B::B(int x, int y) : A(x) // A { **…** }  **const** 5.4 


####  

 class A { … A(void); // A(const A &other); // A & operate =( const A &other); // } 

 class B { public: B(const A &a); // B private: A m_a; // }; 

 9-2(a) B A m_a 9-2 (b) B m_a B m_a A A a m_a 

 B::B(const A &a) : m_a(a) { … } 

 B::B(const A &a) { m_a = a; … } 9-2(a) 9-2(b) 

#### F 

 class F { public: F(int x, int y); // private: int m_x, m_y; int m_i, m_j; 


#### } 

 9-2(c) F 9-2(d) F 

 F::F(int x, int y) : m_x(x), m_y(y) { m_i = 0; m_j = 0; } 

 F::F(int x, int y) { m_x = x; m_y = y; m_i = 0; m_j = 0; } 9-2(c) 9-2(d) 

### 9.3 

 [Eckel, p260-261] 

### 9.4 String 

 // String String:: String(const char *str) { if(str==NULL) { m_data = new char[1]; *m_data = ‘ 0 ’ ; } else { int length = strlen(str); m_data = new char[length+1]; strcpy(m_data, str); 


#### } 

#### } 

 // String String:: ~String(void) { delete [] m_data; // m_data delete m_data; } 

### 9.5 

####  

 String a,b a.m_data hello b.m_data world a b b.m_data = a.m_data b.m_data b.m_data a.m_data a b m_data 

 

 String a( “ hello ” ); String b( “ world ” ); String c = a; // c(a); c = b; // String c(a) 

### 9.6 String 

#### // 

 String::String(const String &other) { 


 // other m_data int length = strlen(other.m_data); m_data = new char[length+1]; strcpy(m_data, other.m_data); } 

 // String & String::operate =(const String &other) { // (1) if(this == &other) return *this; 

 // (2) delete [] m_data; 

 // 3 int length = strlen(other.m_data); m_data = new char[length+1]; strcpy(m_data, other.m_data); 

 // 4 return *this; } 

 String 9.4 NULL NULL NULL String 1 a = a 

#### // 

b = a; **…** c = b; **…** a = c; 

#### // 

 b = &a; … a = *b; 


 delete if if(this == &other) 

 if( *this == other) 2 delete 

 3 strlen 0 strcpy 0 4 a = b = c return *this return this return other 

 other other return other 

### 9.7 

 class A { … private: A(const A &a); // A & operate =(const A &a); // }; 

 A b(a); // b = a; // A 

### 9.8 

####  


 **virtual** #include <iostream.h> class Base { public: virtual ~Base() { cout<< "~Base" << endl ; } }; 

 class Derived : public Base { public: virtual ~Derived() { cout<< "~Derived" << endl ; } }; 

 void main(void) { Base * pB = new Derived; // upcast delete pB; } 

 ~Derived ~Base 

 ~Base 

 class Base { public: **…** Base & operate =(const Base &other); // Base private: int m_i, m_j, m_k; }; 

 class Derived : public Base { public: … 


 Derived & operate =(const Derived &other); // Derived private: int m_x, m_y, m_z; }; 

 Derived & Derived::operate =(const Derived &other) { // 1 if(this == &other) return *this; 

 // 2 Base::operate =(other); // 

 // 3 m_x = other.m_x; m_y = other.m_y; m_z = other.m_z; 

 // 4 return *this; } 

### 9.9 

 C++ Big-Three 

 Big-Three [Cline] [Meyers] [Murry] 


## 10 

 Object Class Instance 

 C++ Inheritance Composition COM CORBA C++ COM CORBA 

### 10.1 

#### A B A B A 

 class A { public: void Func1(void); void Func2(void); }; 

 class B : public A { public: void Func3(void); void Func4(void); }; 

 main() { B b; b.Func1(); // B A Func1 b.Func2(); // B A Func2 b.Func3(); b.Func4(); } 

 C++ 


z **10-1-1 A B B B A** 

z **10-1-2 B A a kind of B A Man Human Boy Man Human Boy Man class Human { … }; class Man : public Human { … }; class Boy : public Man { … };** 

 **10-1-2** 

 Ostrich Bird Ostrich Bird Ostrich::Fly class Bird { public: virtual void Fly(void); … }; 

 class Ostrich : public Bird { … }; 

 Circle Ellipse Circle Ellipse 


#### B A A 

#### B B A 

### 10.2 

z **10-2-1 A B a part of B A A B Eye Nose Mouth Ear Head Head Eye Nose Mouth Ear 10-2-1** 

 class Eye { public: void Look(void); }; 

 class Nose { public: void Smell(void); }; class Mouth { public: void Eat(void); }; 

 class Ear { public: void Listen(void); }; // class Head { public: void Look(void) { m_eye.Look(); } void Smell(void) { m_nose.Smell(); } void Eat(void) { m_mouth.Eat(); } void Listen(void) { m_ear.Listen(); } private: Eye m_eye; Nose m_nose; Mouth m_mouth; Ear m_ear; }; 10-2-1 Head Eye Nose Mouth Ear 

 Head Eye Nose Mouth Ear Head Look 


**Smell Eat Listen 10-2-2** 

#### // 

 class Head : public Eye, public Nose, public Mouth, public Ear { }; 10-2-2 Head Eye Nose Mouth Ear 


## 11 

### 11.1 const 

 const C++ const const const 

**const constant const C++ Use const whenever you need** 

11.1.1 const 

const const  const 

 StringCopy void StringCopy(char *strDestination, const char *strSource); strSource strDestination strSource const strSource 

 const void Func1(int x) void Func1(const int x) void Func2(A a) void Func2(const A a) A 

 void Func(A a) A a 

 void Func(A &a) void Func(A &a) a const void Func(const A &a) void Func(int x) void Func(const int &x) 

 const & 11-1-1 


 const void Func(A a) void Func(const A &a) 

 const void Func(int x) void Func(const int &x) 

 11-1-1 const & 

11.1.2 const  const const 

 const char * GetString(void); 

 char *str = GetString(); 

 const char *str = GetString(); 

 const int GetInt(void) const int GetInt(void) A GetA(void) const A GetA(void) A 

 A GetA(void) const A & GetA(void) 

 6.2 

 

 class A { A & operate = (const A &other); // }; A a, b, c; // a, b, c A 

 a = b = c; // 


 (a = b) = c; // const a = b = c (a = b) = c 

11.1.3 const const const const 

 stack GetCount GetCount const GetCount class Stack { public: void Push(int elem); int Pop(void); int GetCount(void) const; // const private: int m_num; int m_data[100]; }; 

 int Stack::GetCount(void) const { ++ m_num; // m_num Pop(); // const return m_num; } const const 

### 11.2 

z **11-2-1** 


z **11-2-2** 

z **11-2-3** 

z **11-2-4** 

z **11-2-5** 

z **11-2-6** 

### 11.3 

####  11-3-1 

#### || && <= >= 

#### 1 

####  11-3-2 

####  11-3-3 

####  11-3-4 

####  11-3-5 

####  11-3-6 

####  11-3-7 I/O 

####  11-3-8 

####  11-3-9 

####  11-3-10 


####  11-3-11 

####  11-3-12 

####  11-3-13 

 **11-3-14 PC-Lint LogiScope** 


**[Cline] Marshall P. Cline and Greg A. Lomow, C++ FAQs, Addison-Wesley, 1995** 

**[Eckel] Bruce Eckel, Thinking in C++ C++ 2000** 

**[Maguire] Steve Maguire, Writing Clean Code 1993** 

**[Meyers] Scott Meyers, Effective C++, Addison-Wesley, 1992** 

**[Murry] Robert B. Murry, C++ Strategies and Tactics, Addison-Wesley, 1993** 

**[Summit] Steve Summit, C Programming FAQs, Addison-Wesley, 1996** 


## A C++/C 

 ifndef/define/endif? 

**……** 

**“{” “}”** 

**If for while do {} *** 

 public, protected, private 

#### …… 

min-length && max-information 


#### …… 

 if? 1 TRUE FALSE 1 0 

 2 == = 3 == = NULL 

Case break switch default goto? 

 C++ const 

 const const 


 return assert 

 assert 

 return 

 const const Use const whenever you need …… 

 malloc new NULL NULL 

 1 2 free delete NULL malloc/free new/delete malloc 

 new/delete 

#### …… 

**C++** 


 C++ 1 2 3 4 

 1 2 3 4 *this 

 1 

 2 

 3 virtual 

 4 

**……** 

 1 B A A B B A 

**2 A B a part of B A A B ……** 


**I/O** 


## B C++/C 

#### C++/C C++/C 

#### C++/C 

#### 90 

 BOOL , float, if 10 0, 0.0 , FALSE int n if if ( n == 0 ) if ( n != 0 ) 

 BOOL flag if 

 float x if 

 char *p if 

 Windows NT 32 C++ sizeof 10 

 void Func ( char str[100]) { 

 sizeof( str ) = } 

**char str[] = “Hello” ; char *p = str ; int n = 10;** 

 sizeof (str ) = 

 sizeof ( p ) = 

 sizeof ( n ) = 

 void *p = malloc( 100 ); 

 sizeof ( p ) = 


#### 25 

**1 ifndef/define/endif** 

**2 #include <filename.h> #include “filename.h”** 

**3 const** 

**4 C++ C extern “C”** 

**5 for** 

 // for (i=0; i<N; i++) { if (condition) DoSomething(); else DoOtherthing(); } 

#### // 

 if (condition) { for (i=0; i<N; i++) DoSomething(); } else { for (i=0; i<N; i++) DoOtherthing(); } 


#### 20 

void GetMemory(char *p) { p = (char *)malloc(100); } **void Test(void) {** char *str = NULL; GetMemory(str); strcpy(str, "hello world"); printf(str); } 

 Test 

 char *GetMemory(void) { char p[] = "hello world"; return p; } void Test(void) { char *str = NULL; str = GetMemory(); printf(str); } 

 Test 

Void GetMemory2(char **p, int num) { *p = (char *)malloc(num); } void Test(void) { char *str = NULL; GetMemory(&str, 100); strcpy(str, "hello"); printf(str); } Test 

 void Test(void) { char *str = (char *) malloc(100); strcpy(str, “ hello ” ); free(str); if(str != NULL) { strcpy(str, “ world ” ); printf(str); } } Test 


 strcpy 10 strcpy char *strcpy(char *strDest, const char *strSrc); strDest strSrc 

**1 C++/C strcpy** 

**2 strcpy strSrc strDest char *** 

 String 25 String class String { public: String(const char *str = NULL); // String(const String &other); // ~ String(void); // String & operate =(const String &other); // private: char *m_data; // }; String 4 


## C C++/C 

 BOOL , float, if 10 

 BOOL flag if 3 

 if ( flag ) if ( !flag ) 

 if (flag == TRUE) if (flag == 1 ) if (flag == FALSE) if (flag == 0) float x if 4 

**const float EPSINON = 0.00001; if ((x >= EPSINON) && (x <= EPSINON)** == = >= <= 

 if (x == 0.0) if (x != 0.0) 

 char *p if 3 

 if (p == NULL) if (p != NULL) 

 if (p == 0) if (p != 0) if (p) if (!) 

 Windows NT 32 C++ sizeof 10 

 void Func ( char str[100]) { 

 sizeof( str ) = 4 2 } 

 char str[] = “Hello” ; char *p = str ; int n = 10; 

 sizeof (str ) = 6 2 

 sizeof ( p ) = 4 2 

 sizeof ( n ) = 4 2 

 void *p = malloc( 100 ); 

 sizeof ( p ) = 4 2 


#### 25 

**1 ifndef/define/endif 5** 

**2 #include <filename.h> #include “filename.h” 5 #include <filename.h> filename.h #include “filename.h” filename.h** 

**3 const 5 1 const 2 const const** 

**4 C++ C extern “C” 5 C++ C C++ C** void foo(int x, int y); **C _foo C++ _foo_int_int C++ C extern C** 

**5 for 5** 

 for (i=0; i<N; i++) { if (condition) DoSomething(); else DoOtherthing(); } 

 if (condition) { for (i=0; i<N; i++) DoSomething(); } else { for (i=0; i<N; i++) DoOtherthing(); } 

#### N-1 


#### 5 20 

void GetMemory(char *p) { p = (char *)malloc(100); } **void Test(void) {** char *str = NULL; GetMemory(str); strcpy(str, "hello world"); printf(str); } 

 Test 

**GetMemory** Test str NULL strcpy(str, "hello world"); 

 char *GetMemory(void) { char p[] = "hello world"; return p; } void Test(void) { char *str = NULL; str = GetMemory(); printf(str); } 

 Test 

 GetMemory NULL 

void GetMemory2(char **p, int num) { *p = (char *)malloc(num); } void Test(void) { char *str = NULL; GetMemory(&str, 100); strcpy(str, "hello"); printf(str); } Test 

 1 hello 2 

 void Test(void) { char *str = (char *) malloc(100); strcpy(str, “ hello ” ); free(str); if(str != NULL) { strcpy(str, “ world ” ); printf(str); } } Test 

 free(str); str if(str != NULL) 


**strcpy 10 strcpy char *strcpy(char *strDest, const char *strSrc); strDest strSrc 1 C++/C strcpy char *strcpy(char *strDest, const char *strSrc);** { assert(( **str** Dest!=NULL) && ( **strSrc** !=NULL)); // 2 char *address = **str** Dest; // 2 while( (* **str** Dest++ = * **strSrc** ++) != **‘** 0 **’** ) // 2 NULL ; return address ; // 2 } 

 2 strcpy strSrc strDest char * // 2 int length = strlen( strcpy( strDest, “hello world”) ); 

 String 25 String class String { public: String(const char *str = NULL); // String(const String &other); // ~ String(void); // String & operate =(const String &other); // private: char *m_data; // }; String 4 

 // String String:: ~String(void) // 3 { delete [] m_data; // m_data delete m_data; } 


2001 Flyincloud 

 // String String:: String(const char *str) // 6 { if(str==NULL) { m_data = new char[1]; // NULL *m_data = ‘ 0 ’ ; } else { int length = strlen(str); m_data = new char[length+1]; // NULL strcpy(m_data, str); } } // String::String(const String &other) // 3 { int length = strlen(other.m_data); m_data = new char[length+1]; // NULL strcpy(m_data, other.m_data); } // String & String::operate =(const String &other) // 13 { // (1) // 4 if(this == &other) return *this; 

 // (2) // 3 delete [] m_data; 

 // 3 // 3 int length = strlen(other.m_data); m_data = new char[length+1]; // NULL strcpy(m_data, other.m_data); 

 // 4 // 3 return *this; } 


